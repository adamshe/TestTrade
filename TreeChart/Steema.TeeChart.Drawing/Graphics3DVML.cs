namespace Steema.TeeChart.Drawing
{
    using Steema.TeeChart;
    using System;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.IO;

    public class Graphics3DVML : Graphics3DVec
    {
        private int fx;
        private int fy;
        private string m_string;

        public Graphics3DVML(Stream istream, Chart c) : base(istream, c)
        {
            base.AddToStream("<!-- Generated by TeeChart -->");
            base.AddToStream("<body>");
            base.AddToStream("<html>");
            base.AddToStream("<xml:namespace prefix=\"v\"/>");
            base.AddToStream(@"<style>v\:* {behavior=url(#default#VML)}</style>");
        }

        public override void Arc(int x1, int y1, int x2, int y2, float startAngle, float sweepAngle)
        {
            if (base.Pen.Visible)
            {
                int num = 90 + Utils.Round(startAngle);
                int num2 = num + Utils.Round(sweepAngle);
                int num3 = x2 - x1;
                int num4 = y2 - y1;
                this.m_string = "<v:arc style=\"position:absolute;left:" + x1.ToString() + ";top:" + y1.ToString();
                string str = this.m_string;
                this.m_string = str + ";width:" + num3.ToString() + ";height:" + num4.ToString() + "\"";
                str = this.m_string;
                this.m_string = str + " startangle=\"" + num.ToString() + "\" endangle=\"" + num2.ToString() + "\"";
                this.m_string = this.m_string + " filled=\"f\"";
                if (base.Pen.Visible)
                {
                    this.m_string = this.m_string + " strokecolor=" + this.VMLColor(base.Pen.Color, false);
                }
                else
                {
                    this.m_string = this.m_string + " stroked=\"f\"";
                }
                this.m_string = this.m_string + ">";
                base.AddToStream(this.m_string);
            }
        }

        public override void Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
        {
            if (base.Pen.Visible)
            {
                this.PrepareShape();
                this.m_string = "<v:path v=\"ar ";
                string str = this.m_string;
                this.m_string = str + this.PointToStr(x1, y1) + " " + this.PointToStr(x2, y2) + " " + this.PointToStr(x3, y3) + " " + this.PointToStr(x4, y4);
                this.m_string = this.m_string + " e\"/>";
                base.AddToStream(this.m_string);
                base.AddToStream("</v:shape>");
            }
        }

        public override void ClipEllipse(System.Drawing.Rectangle r)
        {
        }

        public override void ClipPolygon(params Point[] p)
        {
        }

        public override void ClipRectangle(System.Drawing.Rectangle r)
        {
        }

        protected override void DoDrawString(int x, int y, string text, ChartBrush aBrush)
        {
            if (base.Font.ShouldDrawShadow())
            {
                this.DoText(base.Font, x + base.Font.Shadow.Width, y + base.Font.Shadow.Height, 0.0, text, aBrush.Color);
            }
            else
            {
                this.DoText(base.Font, x, y, 0.0, text, aBrush.Color);
            }
        }

        private void DoText(ChartFont f, int x, int y, double degAngle, string text, Color c)
        {
            float num = 0f;
            if (base.TextAlign == StringAlignment.Center)
            {
                num = base.TextWidth(text) * 0.5f;
            }
            else if (base.TextAlign == StringAlignment.Far)
            {
                num = base.TextWidth(text);
            }
            x -= Utils.Round(num);
            this.m_string = "<v:textbox style=\"position:absolute; left:" + x.ToString() + "; top:" + y.ToString();
            this.m_string = this.m_string + "; color:" + this.VMLColor(c, true) + "; text-align:left; ";
            this.m_string = this.m_string + this.FontProperties(f) + "\">";
            this.m_string = this.m_string + text;
            this.m_string = this.m_string + "</v:textbox>";
            base.AddToStream(this.m_string);
        }

        public override void Draw(System.Drawing.Rectangle r, Image image, bool transparent)
        {
        }

        public override void Draw(int x, int y, Image image)
        {
        }

        public override void DrawBeziers(params Point[] p)
        {
        }

        private void DrawBrushImage(System.Drawing.Rectangle rect)
        {
        }

        public override void Ellipse(int x1, int y1, int x2, int y2)
        {
            if (base.Brush.Visible || base.Pen.Visible)
            {
                int num = y2 - y1;
                int num2 = x2 - x1;
                this.m_string = "<v:oval style=\"position:absolute;left:" + x1.ToString() + ";top:";
                string str = this.m_string;
                this.m_string = str + y1.ToString() + ";height:" + num.ToString() + ";width:" + num2.ToString() + "\" fillcolor=";
                this.m_string = this.m_string + this.VMLColor(base.Brush.Color, false) + this.VMLPen("oval");
                base.AddToStream(this.m_string);
            }
        }

        public override void EraseBackground(int left, int top, int right, int bottom)
        {
        }

        private string FontProperties(ChartFont f)
        {
            this.m_string = "font-family:" + f.Name.ToString() + "; font-size:" + f.Size.ToString() + "pt; ";
            if (f.Bold)
            {
                this.m_string = this.m_string + " font-weight=bold;";
            }
            if (f.Italic)
            {
                this.m_string = this.m_string + " font-style=italic;";
            }
            if (f.Underline)
            {
                this.m_string = this.m_string + " text-decoration=underline;";
            }
            if (f.Strikeout)
            {
                this.m_string = this.m_string + " text-decoration=line-through;";
            }
            return this.m_string;
        }

        public override void GradientFill(int left, int top, int right, int bottom, Color startColor, Color endColor, LinearGradientMode direction)
        {
            int num;
            if (direction == LinearGradientMode.Vertical)
            {
                num = 180;
            }
            else if (direction == LinearGradientMode.Horizontal)
            {
                num = 90;
            }
            else if (direction == LinearGradientMode.ForwardDiagonal)
            {
                num = 0x2d;
            }
            else
            {
                num = 0x13b;
            }
            this.m_string = "<v:shape style=\"position:absolute;" + this.TheBounds() + ";\" stroked=\"f\">\n";
            this.m_string = this.m_string + " <v:path v=\"M " + this.PointToStr(left, top) + " L ";
            string str = this.m_string;
            this.m_string = str + this.PointToStr(right, top) + " " + this.PointToStr(right, bottom) + " ";
            this.m_string = this.m_string + this.PointToStr(left, bottom) + " X E\"/>\n";
            str = this.m_string;
            this.m_string = str + " <v:fill type=\"gradient\" color=" + this.VMLColor(startColor, false) + " color2=" + this.VMLColor(endColor, false) + "\n";
            if (base.Brush.Gradient.Transparency != 0)
            {
                this.m_string = this.m_string + " opacity=\"" + (((100 - base.Brush.Gradient.Transparency) * 0.01)).ToString("0.00") + "\"";
            }
            this.m_string = this.m_string + " method=\"sigma\" angle=\"" + num.ToString() + "\" focus=\"100%\"/>\n";
            this.m_string = this.m_string + "</v:shape>";
            base.AddToStream(this.m_string);
        }

        public override void HorizontalLine(int left, int right, int y)
        {
            this.MoveTo(left, y);
            this.LineTo(right, y);
        }

        protected internal override void InitWindow(Graphics graphics, Aspect a, System.Drawing.Rectangle r, int MaxDepth)
        {
            base.InitWindow(graphics, a, r, MaxDepth);
            this.m_string = "<v:group style=\"" + this.TheBounds() + "\" ";
            this.m_string = this.m_string + "coordsize=\"" + this.PointToStr(base.chart.ChartBounds.Width, base.chart.ChartBounds.Height) + "\"";
            this.m_string = this.m_string + " coordorigin=\"" + this.PointToStr(base.chart.ChartBounds.Top, base.chart.ChartBounds.Left) + "\">";
            base.AddToStream(this.m_string);
        }

        private void InternalPolygon(ChartBrush br, ChartPen pn, bool PolyLine, params Point[] p)
        {
            if (br.Visible || pn.Visible)
            {
                this.PrepareShape();
                this.m_string = "<v:path v=\"m " + this.PointToStr(p[0].X, p[0].Y) + " l ";
                for (int i = 1; i <= p.GetUpperBound(0); i++)
                {
                    this.m_string = this.m_string + this.PointToStr(p[i].X, p[i].Y) + " ";
                }
                if (PolyLine)
                {
                    this.m_string = this.m_string + " e\"/>";
                }
                else
                {
                    this.m_string = this.m_string + " x e\"/>";
                }
                base.AddToStream(this.m_string);
                base.AddToStream("</v:shape>");
            }
        }

        private void InternalRect(ChartBrush b, System.Drawing.Rectangle r, bool UsePen, bool IsRound)
        {
            if (b.Visible || (UsePen && base.Pen.Visible))
            {
                this.m_string = "<v:";
                string element = "rect";
                if (IsRound)
                {
                    element = "roundrect";
                }
                this.m_string = this.m_string + element;
                this.m_string = this.m_string + " style=\"position:absolute;left:";
                string str3 = this.m_string;
                this.m_string = str3 + r.Left.ToString() + ";top:" + r.Top.ToString() + ";width:";
                int num = r.Width - 1;
                this.m_string = this.m_string + num.ToString() + ";height:";
                this.m_string = this.m_string + ((r.Height - 1)).ToString() + "\"";
                if (b.Visible)
                {
                    this.m_string = this.m_string + " fillcolor=" + this.VMLColor(b.Color, false);
                }
                else
                {
                    this.m_string = this.m_string + " filled=\"false\"";
                }
                if (UsePen && base.Pen.Visible)
                {
                    this.m_string = this.m_string + " strokecolor=" + this.VMLColor(base.Pen.Color, false);
                }
                else
                {
                    this.m_string = this.m_string + " stroked=\"f\"";
                }
                float num2 = 1f - (b.Transparency * 0.01f);
                if (num2 < 1f)
                {
                    string str2 = num2.ToString().Replace(',', '.');
                    this.m_string = this.m_string + " opacity=\"" + str2 + "\"";
                }
                this.m_string = this.m_string + this.VMLPen(element);
                base.AddToStream(this.m_string);
            }
        }

        protected override void Line(ChartPen p, Point a, Point b)
        {
            this.MoveTo(a.X, a.Y);
            this.LineTo(b.X, b.Y);
        }

        public override void Line(int x0, int y0, int x1, int y1)
        {
            this.MoveTo(x0, y0);
            this.LineTo(x1, y1);
        }

        public override void LineTo(int x, int y)
        {
            base.AddToStream("<v:line from=\"" + this.PointToStr(this.fx, this.fy) + "\" to=\"" + this.PointToStr(x, y) + this.VMLPen("line"));
            this.fx = x;
            this.fy = y;
        }

        public override SizeF MeasureString(ChartFont f, string text)
        {
            return base.g.MeasureString(text, f.DrawingFont);
        }

        public override void MoveTo(int x, int y)
        {
            this.fx = x;
            this.fy = y;
        }

        private string PenStyle(ChartPen ipen)
        {
            if (ipen.Style == DashStyle.Solid)
            {
                return "";
            }
            return ipen.Style.ToString();
        }

        private string PenWidth(ChartPen ipen, string element)
        {
            if (ipen.Width > 1)
            {
                this.m_string = " " + element + "=\"" + ipen.Width.ToString() + "\"";
            }
            else
            {
                this.m_string = "";
            }
            return this.m_string;
        }

        public override void Pie(int x1, int y1, int x2, int y2, double startAngle, double endAngle)
        {
            if (base.Brush.Visible || base.Pen.Visible)
            {
                this.PrepareShape();
                int x = (x2 + x1) / 2;
                int y = (y2 + y1) / 2;
                int num3 = (x2 - x1) / 2;
                int num4 = (y2 - y1) / 2;
                startAngle = (startAngle * 3.1415926535897931) / 180.0;
                endAngle = (endAngle * 3.1415926535897931) / 180.0;
                int num5 = x + Utils.Round((double) (num3 * Math.Cos(startAngle)));
                int num6 = y - Utils.Round((double) (num4 * Math.Sin(startAngle)));
                int num7 = x + Utils.Round((double) (num3 * Math.Cos(endAngle)));
                int num8 = y - Utils.Round((double) (num4 * Math.Sin(endAngle)));
                this.m_string = "<v:path v=\"m " + this.PointToStr(x, y) + " at ";
                string str = this.m_string;
                this.m_string = str + this.PointToStr(x1, y1) + " " + this.PointToStr(x2, y2) + " ";
                this.m_string = this.m_string + this.PointToStr(num5, num6) + " " + this.PointToStr(num7, num8);
                this.m_string = this.m_string + " x e\"/>";
                base.AddToStream(this.m_string);
                base.AddToStream("</v:shape>");
            }
        }

        public override void Pixel(int x, int y, int z, Color color)
        {
        }

        private string PointToStr(int x, int y)
        {
            this.m_string = x.ToString() + "," + y.ToString();
            return this.m_string;
        }

        public override void Polygon(params Point[] p)
        {
            this.InternalPolygon(base.Brush, base.Pen, false, p);
        }

        public override void Polygon(Brush b, params Point[] p)
        {
        }

        public override void Polyline(int z, params Point[] p)
        {
            this.InternalPolygon(base.Brush, base.Pen, true, p);
        }

        public override void PrepareDrawImage()
        {
        }

        private void PrepareShape()
        {
            this.m_string = "<v:shape style=\"position:absolute;" + this.TheBounds() + "\"";
            if (base.Brush.Visible)
            {
                this.m_string = this.m_string + " fillcolor=" + this.VMLColor(base.Brush.Color, false);
            }
            else
            {
                this.m_string = this.m_string + " filled=\"f\"";
            }
            if (base.Pen.Visible)
            {
                this.m_string = this.m_string + " strokecolor=" + this.VMLColor(base.Pen.Color, false);
            }
            else
            {
                this.m_string = this.m_string + " stroked=\"f\"";
            }
            float num = 1f - (base.Brush.Transparency * 0.01f);
            if (num < 1f)
            {
                string str = num.ToString().Replace(',', '.');
                this.m_string = this.m_string + " opacity=\"" + str + "\"";
            }
            this.m_string = this.m_string + ">";
            base.AddToStream(this.m_string);
        }

        public override void Rectangle(System.Drawing.Rectangle r)
        {
            this.InternalRect(base.Brush, r, true, false);
        }

        public override void Rectangle(Brush b, System.Drawing.Rectangle r)
        {
        }

        public override void RotateLabel(int x, int y, string text, double rotDegree)
        {
            this.DoText(base.Font, x, y, rotDegree, text, base.Font.Color);
        }

        public override void RoundRectangle(System.Drawing.Rectangle r, int roundWidth, int roundHeight)
        {
            this.InternalRect(base.Brush, r, true, true);
        }

        public override void ShowImage()
        {
            base.AddToStream("</v:group>");
            base.AddToStream("</body>");
            base.AddToStream("</html>");
        }

        private string TheBounds()
        {
            this.m_string = "width:" + base.chart.ChartBounds.Width.ToString();
            this.m_string = this.m_string + ";height:" + base.chart.ChartBounds.Height.ToString();
            return this.m_string;
        }

        internal override void TransparentEllipse(int x1, int y1, int x2, int y2)
        {
            int num = y2 - y1;
            int num2 = x2 - x1;
            this.m_string = "<v:oval style=\"position:absolute;left:" + x1.ToString() + ";top:";
            string str = this.m_string;
            this.m_string = str + y1.ToString() + ";height:" + num.ToString() + ";width:" + num2.ToString() + "\" filled=\"f\"";
            this.m_string = this.m_string + this.VMLPen("oval");
            base.AddToStream(this.m_string);
        }

        public override void UnClip()
        {
        }

        public override void VerticalLine(int x, int top, int bottom)
        {
            this.MoveTo(x, bottom);
            this.LineTo(x, top);
        }

        private string VMLColor(Color c, bool inter)
        {
            if (!inter)
            {
                this.m_string = "\"";
            }
            else
            {
                this.m_string = "";
            }
            if (c == Color.Black)
            {
                this.m_string = this.m_string + "black";
            }
            else if (c == Color.Silver)
            {
                this.m_string = this.m_string + "silver";
            }
            else if (c == Color.Gray)
            {
                this.m_string = this.m_string + "gray";
            }
            else if (c == Color.White)
            {
                this.m_string = this.m_string + "white";
            }
            else if (c == Color.Maroon)
            {
                this.m_string = this.m_string + "maroon";
            }
            else if (c == Color.Red)
            {
                this.m_string = this.m_string + "red";
            }
            else if (c == Color.Purple)
            {
                this.m_string = this.m_string + "purple";
            }
            else if (c == Color.Fuchsia)
            {
                this.m_string = this.m_string + "fuchsia";
            }
            else if (c == Color.Green)
            {
                this.m_string = this.m_string + "green";
            }
            else if (c == Color.Lime)
            {
                this.m_string = this.m_string + "lime";
            }
            else if (c == Color.Olive)
            {
                this.m_string = this.m_string + "olive";
            }
            else if (c == Color.Yellow)
            {
                this.m_string = this.m_string + "yellow";
            }
            else if (c == Color.Navy)
            {
                this.m_string = this.m_string + "navy";
            }
            else if (c == Color.Blue)
            {
                this.m_string = this.m_string + "blue";
            }
            else if (c == Color.Teal)
            {
                this.m_string = this.m_string + "teal";
            }
            else if (c == Color.Aqua)
            {
                this.m_string = this.m_string + "aqua";
            }
            else
            {
                this.m_string = this.m_string + "#" + c.R.ToString("X2");
                this.m_string = this.m_string + c.G.ToString("X2");
                this.m_string = this.m_string + c.B.ToString("X2");
            }
            if (!inter)
            {
                this.m_string = this.m_string + "\"";
            }
            return this.m_string;
        }

        private string VMLPen(string element)
        {
            this.m_string = "\" strokecolor=" + this.VMLColor(base.Pen.Color, false);
            if (base.Pen.Style != DashStyle.Solid)
            {
                string str = this.m_string;
                this.m_string = str + "><v:stroke dashstyle=\"" + this.PenStyle(base.Pen) + "\"" + this.PenWidth(base.Pen, "weight") + "/></v:" + element + ">";
            }
            else
            {
                this.m_string = this.m_string + this.PenWidth(base.Pen, "strokeweight") + "/>";
            }
            return this.m_string;
        }
    }
}

